### IMPORTS ###
import nmdTemp as nt
import pypar
import multiprocessing as mp
from lammps import lammps
import ctypes
import numpy as np
import sys
sys.path.append('/home/kevin/projects/ntpy')
# import ntpy.lattice as lt
# import ntpy.param.lj as lj
import ntpy.nmd as norm

### Parameters ###
# SED params
seed = 'SEED'


# numTstep = 1024
# numTstep = 2**13
# numAtoms = 256
numTstep = nt.numTstep
numAtoms = nt.numAtoms

proc = pypar.size()
myid = pypar.rank()

# Number of atoms calculated on by each lmp processs
assert 256 % pypar.size() == 0
numA2 = 256 / pypar.size()

## Create velocity Arrays
# If main process
if myid == 0:
	# velx = np.zeros( (numTstep, numAtoms), dtype=float)
	# vely = np.zeros( (numTstep, numAtoms), dtype=float)
	# velz = np.zeros( (numTstep, numAtoms), dtype=float)
	velx_base = mp.Array(ctypes.c_double, numTstep*numAtoms)
	velx = np.ctypeslib.as_array(velx_base.get_obj())
	velx = velx.reshape(numTstep, numAtoms)
	vely_base = mp.Array(ctypes.c_double, numTstep*numAtoms)
	vely = np.ctypeslib.as_array(vely_base.get_obj())
	vely = vely.reshape(numTstep, numAtoms)
	velz_base = mp.Array(ctypes.c_double, numTstep*numAtoms)
	velz = np.ctypeslib.as_array(velz_base.get_obj())
	velz = velz.reshape(numTstep, numAtoms)
	print velx.shape
	print vely.shape
	print velz.shape


# Else, if not main process
else:
	tmpVelx = np.zeros( (numA2), dtype=float)
	tmpVely = np.zeros( (numA2), dtype=float)
	tmpVelz = np.zeros( (numA2), dtype=float)


###--- MAIN ---###
lmp1 = lammps()
lmp1.file(nt.lammpsRunName + seed)
print "Proc %d out of %d procs has" % (pypar.rank(),pypar.size()),lmp1

# Pre load functions 
lmpC = lmp1.command
lmpEV = lmp1.extract_variable
pyparR = pypar.receive
pyparS = pypar.send

### Lammps Run
for istep in range(numTstep):
	lmpC('run 32 pre no post yes')
	# If main mpi process
	if myid == 0:
		# First get the velocities associated with this mpi process
 		velx[istep, 0:numA2*(1)] = lmpEV("vx", "all", 1)
 		vely[istep, 0:numA2*(1)] = lmpEV("vy", "all", 1)
 		velz[istep, 0:numA2*(1)] = lmpEV("vz", "all", 1)	
		# Next, collect the velocities from all the other mpi processes
		for i in range(1, proc):
			velx[istep, numA2*i:numA2*(i+1)] = pyparR(source=i, buffer=velx[istep,numA2*i:numA2*(i+1)], tag=1)
			vely[istep, numA2*i:numA2*(i+1)] = pyparR(source=i, buffer=vely[istep,numA2*i:numA2*(i+1)], tag=2)
			velz[istep, numA2*i:numA2*(i+1)] = pyparR(source=i, buffer=velz[istep,numA2*i:numA2*(i+1)], tag=3)

	# Else, if not the main mpi process
	else:
		# Run and send the velocity information back to proc 0
		tmpVelx[:] = lmpEV("vx", "all", 1)
		tmpVely[:] = lmpEV("vy", "all", 1)
		tmpVelz[:] = lmpEV("vz", "all", 1)
		pyparS(tmpVelx, destination=0, use_buffer=True, tag=1)
		pyparS(tmpVely, destination=0, use_buffer=True, tag=2)
		pyparS(tmpVelz, destination=0, use_buffer=True, tag=3)
#-- END Lammps Run --#


# Only perform on main mpi process
if myid == 0:
	# print velx
	# print vely
	# print velz
	print "==============================================================="
	print "==============================================================="
	print "==============================================================="

	def nmdProc(latPosx, latPosy, latPosz,
			latVecx, latVecy, latVecz, kpt, ikpt, imode, numAtomsUC, numUC, mass,
			numTstep, out_q, eigvec):

		# Initialize qdot
		qdot = np.zeros( (numTstep) )

		# Prereference functions
		tile = np.tile
		conjugate = ma.conjugate

		# Spatial fourier transform factor
		spatial = 2.0 * np.pi * 1j * (\
			latPosx[:]*( (kpt[ikpt,0])/(latVecx) ) + \
			latPosy[:]*( (kpt[ikpt,1])/(latVecy) ) + \
			latPosz[:]*( (kpt[ikpt,2])/(latVecz) ) ) 
	
		# Conjugate eigenvectors
		eigx = tile(conjugate(eigenVector[(numAtomsUC*3*ikpt)+0: \
					(numAtomsUC*3*(ikpt+1)):3, imode]),numUC)
		eigy = tile(conjugate(eigenVector[(numAtomsUC*3*ikpt)+1: \
					(numAtomsUC*3*(ikpt+1)):3, imode]),numUC)
		eigz = tile(conjugate(eigenVector[(numAtomsUC*3*ikpt)+2: \
					(numAtomsUC*3*(ikpt+1)):3, imode]),numUC)

		# qdot: normal mode kinetic energy corrdinate
		qdot = np.sum(((velx * eigx) + (vely * eigy) + (velz * eigz)) * \
				np.exp(spatial) * np.sqrt(mass/numUC), axis=1)

		# keXcorr: kinetic energy autocorrelation
		result = np.correlate(qdot, qdot, mode='full', old_behavior=False)
		keXcorr = result[result.size/2:] / result[result.size/2]
	
		# keFft: kinetic energy FFT
		keFft = np.fft.fft(keXcorr[:])
	
		# specEDFft: spectral energy density for a single FFT
		specEDFft = (keFft[:].real * keFft[:].real) + \
				(keFft[:].imag * keFft[:].imag)

		# Add spectral energy denisty for a single FFT to whole
		out_q.put(specEDFft[:numTstep/2])
	#-- END nmdProc --#

	# Decide is shared mem for eigenvectors
	# if nt.gamma == True:
		# gulp = np.load('post.gulp.npz')
		# eigvec_base = mp.Array(ctypes.c_double, numTstep*numAtoms)
		# eigvec = np.ctypeslib.as_array(eigvec_base.get_obj())
		# eigvec = eigvec.reshape(nt.numAtoms * nt.numModes, nt.numModes)
		# eigvec[:,:] = gulp['eigvec']
	# else:
		# gulp = np.load('post.gulp.npz')
		# eigvec[:,:] = gulp['eigvec']
	
	# Load Eigenvectors
	gulp = np.load('post.gulp.npz')
	eigvec[:,:] = gulp['eigvec']

	out_q = mp.Queue()
	procs = []
	for ikpt in range(nt.numKpts):
		for imode in range(nt.numModes):

			# Gamma, shared mem for eigvecs switch
			if nt.gamma == True:
				p = mp.Process(
					target=worker,
					args=(nt.latPosx, nt.latPosy, nt.latPosz,
							nt.latVecx, nt.latVecy, nt.latVecz, nt.kpt, ikpt,
							imode, nt.numAtomsUC, nt.numUC, nt.ljMass, nt.numTstep,
							out_q))
			else:
				p = mp.Process(
					target=nmdProc,
					args=(nt.latPosx, nt.latPosy, nt.latPosz,
							nt.latVecx, nt.latVecy, nt.latVecz, nt.kpt, ikpt,
							imode, nt.numAtomsUC, nt.numUC, nt.ljMass, nt.numTstep,
							out_q, eigvec))

			procs.append(p)
			p.start()

	for i in range(nt.numKpts * nt.numModes):
		print out_q.get()

	for p in procs:
		p.join()
		
# FINISH PYPAR
pypar.finalize() 
print 'last line of python script'
